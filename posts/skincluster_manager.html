<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Mastering Deformation Layers - Guido Gonzalez</title>
  <meta name="description" content="Optimizing skin weight IO in Maya using OpenMaya API and JSON sparse data." />
  
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600&family=JetBrains+Mono:wght@400&display=swap" />
  <link href="https://api.fontshare.com/v2/css?f[]=clash-display@600,700,500&display=swap" rel="stylesheet">

  <style>
    /* === Base Variables === */
    :root {
      --bg-color: #050505;
      --text-color: #e0e0e0;
      --code-bg: #111;
      --accent: #009dff; /* Azul para tech/API */
      --border: #333;
    }

    body {
      margin: 0;
      font-family: "Inter", sans-serif;
      background-color: var(--bg-color);
      color: var(--text-color);
      line-height: 1.8;
      background-image: url('../assets/bg.jpg');
      background-attachment: fixed;
    }

    /* === Nav === */
    nav {
      display: flex;
      justify-content: center;
      gap: 2rem;
      padding: 30px 0;
      border-bottom: 1px solid #1a1a1a;
      background: rgba(5,5,5,0.8);
      backdrop-filter: blur(10px);
      position: sticky;
      top: 0;
      z-index: 100;
    }
    nav a { text-decoration: none; color: #888; transition: color 0.3s; font-size: 0.9rem;}
    nav a:hover { color: #fff; }

    /* === Layout === */
    .article-wrapper {
      max-width: 850px;
      margin: 0 auto;
      padding: 4rem 20px;
    }

    /* === Header === */
    .post-header {
      margin-bottom: 4rem;
      border-bottom: 1px solid var(--border);
      padding-bottom: 2rem;
    }

    h1 {
      font-family: 'Clash Display', sans-serif;
      font-size: clamp(2.5rem, 5vw, 4rem);
      line-height: 1.1;
      margin: 1rem 0;
      color: #fff;
    }

    .tags {
      display: flex;
      gap: 10px;
      margin-bottom: 1.5rem;
    }

    .tag {
      background: rgba(0, 157, 255, 0.1);
      padding: 5px 12px;
      border-radius: 100px;
      font-size: 0.8rem;
      font-weight: 600;
      color: var(--accent);
      border: 1px solid rgba(0, 157, 255, 0.2);
    }

    /* === Content Typography === */
    h2 {
      font-family: 'Clash Display', sans-serif;
      font-size: 2rem;
      margin-top: 4rem;
      margin-bottom: 1.5rem;
      color: #fff;
      display: flex;
      align-items: center;
      gap: 1rem;
    }
    
    h2::before {
      content: '';
      display: block;
      width: 8px;
      height: 8px;
      background: var(--accent);
      border-radius: 50%;
    }

    h3 {
      font-size: 1.3rem;
      color: #ccc;
      margin-top: 2.5rem;
    }

    p { color: #b0b0b0; font-size: 1.05rem; margin-bottom: 1.5rem; }

    ul { color: #b0b0b0; margin-bottom: 2rem; }
    li { margin-bottom: 0.5rem; }

    /* === Code Blocks === */
    pre {
      background: var(--code-bg);
      padding: 1.5rem;
      border-radius: 8px;
      overflow-x: auto;
      border: 1px solid var(--border);
      box-shadow: 0 10px 30px rgba(0,0,0,0.3);
      position: relative;
    }

    pre::before {
      content: 'PYTHON API';
      position: absolute;
      top: 0;
      right: 0;
      background: #222;
      color: #666;
      font-size: 0.7rem;
      padding: 4px 10px;
      border-bottom-left-radius: 8px;
    }

    code {
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.85rem;
      color: #d4d4d4;
    }

    /* Syntax Highlighting Simulation */
    .k { color: #c678dd; } /* Keyword */
    .f { color: #61afef; } /* Function */
    .s { color: #98c379; } /* String */
    .c { color: #5c6370; font-style: italic; } /* Comment */
    .n { color: #d19a66; } /* Number */
    .o { color: #56b6c2; } /* Operator */
    .cl { color: #e5c07b; } /* Class */

    /* === Images === */
    img {
      width: 100%;
      border-radius: 8px;
      margin: 2rem 0;
      border: 1px solid var(--border);
    }
    
    .caption {
      text-align: center;
      font-size: 0.85rem;
      color: #666;
      margin-top: -1.5rem;
      margin-bottom: 2rem;
    }
  </style>
</head>

<body>
  <nav>
    <a href="../index.html">HOME</a>
    <a href="../about.html">ABOUT ME</a>
    <a href="../blog.html" class="active">BLOG</a>
  </nav>

  <article class="article-wrapper">
    
    <header class="post-header">
      <div class="tags">
        <span class="tag">OPENMAYA</span>
        <span class="tag">OPTIMIZATION</span>
        <span class="tag">TOOL DEV</span>
      </div>
      <h1>Mastering Deformation Layers</h1>
      <p style="font-size: 1.2rem; color: #888;">
        Why simple XML exports aren't enough: A look at high-performance skin I/O, sparse data handling, and managing deformation stacks.
      </p>
    </header>

    <section>
      <p>
        In modern production rigging, a single SkinCluster is rarely enough. We stack corrective skins, squash & stretch layers, and simulations. Managing these "Deformation Layers" efficiently is critical.
      </p>
      <p>
        Default Maya export tools (like <code>deformerWeights</code>) are slow and often produce bloated files. To solve this, I wrote a custom <code>SkinIO</code> manager using <strong>Maya's API 2.0 (OpenMaya)</strong>.
      </p>
    </section>

    <section>
      <h2>1. The Performance Gap: cmds vs OpenMaya</h2>
      <p>
        When you have a mesh with 50,000 vertices and 100 joints, you are dealing with 5 million potential weight values. Using <code>maya.cmds.skinPercent</code> loops through these values as strings, which is excruciatingly slow.
      </p>
      <p>
        By switching to `maya.api.OpenMaya`, we can access the raw memory array of weights directly. In my <code>SkinIO</code> class, querying weights happens in a fraction of a second using <code>MFnSkinCluster.getWeights()</code>.
      </p>

      <pre><code><span class="c"># Accessing raw weight arrays via API</span>
<span class="k">def</span> <span class="f">_get_skin_weights</span>(<span class="n">self</span>, <span class="n">mf_skin</span>, <span class="n">vtx_count</span>):
    <span class="n">single_comp</span> <span class="o">=</span> <span class="cl">om</span>.<span class="cl">MFnSingleIndexedComponent</span>()
    <span class="n">vertex_comp</span> <span class="o">=</span> <span class="n">single_comp</span>.<span class="f">create</span>(<span class="cl">om</span>.<span class="cl">MFn</span>.<span class="n">kMeshVertComponent</span>)
    <span class="n">single_comp</span>.<span class="f">setCompleteData</span>(<span class="n">vtx_count</span>)
    
    <span class="c"># This single line replaces thousands of cmds.skinPercent calls</span>
    <span class="n">weights_marray</span>, <span class="n">_</span> <span class="o">=</span> <span class="n">mf_skin</span>.<span class="f">getWeights</span>(<span class="n">mesh_path</span>, <span class="n">vertex_comp</span>)
    <span class="k">return</span> <span class="cl">list</span>(<span class="n">weights_marray</span>)</code></pre>
    </section>

    <section>
      <h2>2. Sparse Data Optimization</h2>
      <p>
        A standard character mesh is "sparse". This means that while there might be 200 joints in the skeleton, a vertex on the pinky toe is only influenced by 1 or 2 joints. Storing <code>0.0</code> for the other 198 joints is a waste of disk space.
      </p>
      <p>
        My exporter checks against a tolerance (<code>1e-5</code>). If a weight is negligible, it is not written to the JSON. This reduces file sizes by up to 90% compared to raw dumps.
      </p>

      <pre><code><span class="c"># Only storing values that matter</span>
<span class="k">for</span> <span class="n">v_idx</span> <span class="k">in</span> <span class="f">range</span>(<span class="n">vtx_count</span>):
    <span class="n">val</span> <span class="o">=</span> <span class="n">flat_weights</span>[<span class="n">v_idx</span> <span class="o">*</span> <span class="n">stride</span> <span class="o">+</span> <span class="n">inf_idx</span>]
    
    <span class="c"># Optimization Check</span>
    <span class="k">if</span> <span class="n">val</span> <span class="o">></span> <span class="n">self</span>.<span class="n">tolerance</span>:
        <span class="n">j_indices</span>.<span class="f">append</span>(<span class="n">v_idx</span>)
        <span class="n">j_weights</span>.<span class="f">append</span>(<span class="f">round</span>(<span class="n">val</span>, <span class="n">5</span>))</code></pre>
    </section>

    <section>
      <h2>3. Handling Deformation Layers</h2>
      <p>
        When importing skins, order matters. If you have a base SkinCluster and a corrective SkinCluster on top, applying them in the wrong order destroys the deformation.
      </p>
      <p>
        The tool iterates through the history using <code>cmds.listHistory</code> to capture the exact stack order. During import, it rebuilds the stack and ensures the new deformers are reordered correctly using <code>reorderDeformers</code>.
      </p>
      <pre><code><span class="c"># Re-stacking deformers upon import</span>
<span class="k">for</span> <span class="n">skin</span> <span class="k">in</span> <span class="f">reversed</span>(<span class="n">order</span>):
    <span class="k">try</span>: 
        <span class="cl">cmds</span>.<span class="f">reorderDeformers</span>(<span class="n">skin</span>, <span class="n">mesh_full_path</span>, <span class="n">back</span>=<span class="k">True</span>)
    <span class="k">except</span>: 
        <span class="k">pass</span></code></pre>
    </section>

    <section>
      <h2>Conclusion</h2>
      <p>
        This modular approach to skin IO allows for transferring weights between assets with different topologies (by mapping indices if needed) or simply backing up complex rigged characters efficiently. The combination of OpenMaya for speed and JSON for readability makes it a robust pipeline tool.
      </p>
    </section>

  </article>
</body>
</html>